[<AutoOpen>]
module rec Config

open Argu
open System
open System.IO

[<RequireQualifiedAccess>]
type PathType =
    | CsFile of string | DllFile of string | Directory of string | InvalidPath

type Args =
    | [<MainCommand; Mandatory; First;>] Input of Path:string
    | [<AltCommandLine("-r")>] Recurse
    | [<AltCommandLine("-o")>] Output of Path:string
    | [<AltCommandLine("-x")>] Extension of string
    | [<AltCommandLine("-h")>] Header of string option
    | [<AltCommandLine("-v")>] View
    | [<AltCommandLine("-q")>] Quiet
    | With of string list
    | Without of string list
    with interface IArgParserTemplate with member a.Usage = argHelp a

let private argHelp a =
    match a with
    | Input _ -> """
Input path, absolute or relative to the current directory.
  If the path is a directory, all .cs files will be used.
  If no .cs files are found, an error is returned.
"""
    | Recurse -> """
Search all subdirectories.
"""
    | Output _ -> """
Output directory path.
  If the provided path does not exist, it will be created.
  If no valid path is provided, the current directory is used.
"""
    | Extension _ -> """
Apex file extension.
  Defaults to .cls.
"""
    | Header _ -> """
Include a comment at the top of each Apex file.
  Provide your own text or leave blank to use the default.
"""
    | View -> """
Skip creating output files.
  View transformed contents in the console.
"""
    | Quiet -> """
No console output.
  Ignored if View is used.
"""
    | With _ -> """
Include these types by fully qualified class name.
  Use an asterisk (*) to match everything in a namespace.
  Format: unquoted, case-sensitive, space-delimited list.
"""
    | Without _ -> """
Exclude these types by fully qualified class name.
  Use an asterisk (*) to match everything in a namespace.
  Format: unquoted, case-sensitive, space-delimited list.
"""

let updateConfig cfg arg =
    match arg with
    | Input p ->
        { cfg with Input = pathType p }
    | Recurse ->
        { cfg with Recurse = true }
    | Output p ->
        let existsOrCreated = 
            try
                Directory.CreateDirectory p |> ignore
                true
            with | ex ->
                printfn $"Error creating output directory: {ex.Message}" |> ignore
                false
        { cfg with OutputDir = if existsOrCreated then p else cfg.OutputDir }
    | Extension e ->
        let extn =
            if String.IsNullOrWhiteSpace e then cfg.ApexExtn else e
        { cfg with ApexExtn = extn }
    | Header h ->
        { cfg with Header = h |> Option.orElse defaultHeader }
    | View ->
        { cfg with View = true; Quiet = false; }
    | Quiet ->
        { cfg with Quiet = not cfg.View }
    | With c ->
        { cfg with WithTypes = c }
    | Without c -> 
        { cfg with WithoutTypes = c }

type Config =
    { Input : PathType
      OutputDir : string
      ApexExtn : string
      Header : string option
      Recurse : bool
      View : bool
      Quiet : bool
      WithTypes : string list
      WithoutTypes : string list
    }
    static member Zero =
        { Input = PathType.InvalidPath
          OutputDir = Directory.GetCurrentDirectory ()
          ApexExtn = ".cls"
          Header = None
          Recurse = false
          View = false
          Quiet = false
          WithTypes = List.empty
          WithoutTypes = List.empty
        }

let private defaultHeader =
    Some $"// This file was generated by ToApexClass on {DateTime.Now}."

let private pathType path =
    if Directory.Exists path then
        PathType.Directory path
    elif File.Exists path then
        let extn = Path.GetExtension path
        if extn = ".cs" then
            PathType.CsFile path
        elif extn = ".dll" then
            PathType.DllFile path
        else 
            PathType.InvalidPath
    else 
        PathType.InvalidPath

let private errHandler =
    ProcessExiter (colorizer = function 
        | ErrorCode.HelpText -> None 
        | ErrorCode.PostProcess -> Some ConsoleColor.DarkYellow
        | _ -> Some ConsoleColor.Red)

let private checkStructure =
#if DEBUG
    true
#else
    false
#endif

let argParser =
    ArgumentParser.Create<Args> (
        programName = "toapexclass", 
        errorHandler = errHandler,
        checkStructure = checkStructure)

let allParseResults argv =
    argParser.Parse argv
    |> fun a -> a.GetAllResults ()

let toConfig =
    List.fold updateConfig Config.Zero
